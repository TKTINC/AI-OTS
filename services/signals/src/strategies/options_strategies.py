"""
Advanced Trading Strategy Algorithms for AI Options Trading System
Specialized algorithms designed to identify consistent 5-10% profit opportunities
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timezone, timedelta
from dataclasses import dataclass
from enum import Enum
import logging
import math
from scipy import stats
from scipy.optimize import minimize_scalar

logger = logging.getLogger(__name__)

class StrategyType(Enum):
    """Types of trading strategies"""
    MOMENTUM = "momentum"
    MEAN_REVERSION = "mean_reversion"
    BREAKOUT = "breakout"
    VOLATILITY = "volatility"
    ARBITRAGE = "arbitrage"
    GAMMA_SCALPING = "gamma_scalping"
    DELTA_NEUTRAL = "delta_neutral"

@dataclass
class StrategySignal:
    """Signal generated by a trading strategy"""
    strategy_name: str
    strategy_type: StrategyType
    signal_strength: float  # 0.0 to 1.0
    confidence: float       # 0.0 to 1.0
    entry_price: float
    target_price: float
    stop_loss: float
    position_size: float
    expected_return: float
    max_risk: float
    time_horizon: int       # Hours
    reasoning: str
    technical_factors: Dict[str, Any]
    options_factors: Dict[str, Any]
    risk_factors: Dict[str, Any]

class OptionsStrategyEngine:
    """Advanced options trading strategy engine"""
    
    def __init__(self):
        self.strategies = {
            "momentum_breakout": self._momentum_breakout_strategy,
            "volatility_squeeze": self._volatility_squeeze_strategy,
            "gamma_scalping": self._gamma_scalping_strategy,
            "delta_neutral_straddle": self._delta_neutral_straddle_strategy,
            "iron_condor_range": self._iron_condor_range_strategy,
            "butterfly_pinning": self._butterfly_pinning_strategy,
            "earnings_volatility": self._earnings_volatility_strategy,
            "gap_fill_reversal": self._gap_fill_reversal_strategy,
            "support_resistance_bounce": self._support_resistance_bounce_strategy,
            "vix_divergence": self._vix_divergence_strategy
        }
        
        # Strategy performance tracking
        self.strategy_performance = {}
        self.strategy_weights = {
            "momentum_breakout": 0.15,
            "volatility_squeeze": 0.12,
            "gamma_scalping": 0.10,
            "delta_neutral_straddle": 0.08,
            "iron_condor_range": 0.10,
            "butterfly_pinning": 0.08,
            "earnings_volatility": 0.12,
            "gap_fill_reversal": 0.10,
            "support_resistance_bounce": 0.10,
            "vix_divergence": 0.05
        }
    
    def analyze_opportunities(self, symbol: str, market_data: Dict[str, Any], 
                            analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> List[StrategySignal]:
        """Analyze all trading opportunities for a symbol"""
        signals = []
        
        for strategy_name, strategy_func in self.strategies.items():
            try:
                signal = strategy_func(symbol, market_data, analytics_data, options_data)
                if signal and self._validate_strategy_signal(signal):
                    signals.append(signal)
            except Exception as e:
                logger.error(f"Error in strategy {strategy_name} for {symbol}: {e}")
        
        # Sort by expected return and confidence
        signals.sort(key=lambda s: s.expected_return * s.confidence, reverse=True)
        
        return signals
    
    def _momentum_breakout_strategy(self, symbol: str, market_data: Dict[str, Any],
                                  analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Momentum breakout strategy for options"""
        try:
            current_price = market_data.get("current_price", 0)
            volume = market_data.get("volume", 0)
            avg_volume = market_data.get("avg_volume", volume)
            
            indicators = analytics_data.get("indicators", {})
            patterns = analytics_data.get("patterns", {})
            
            # Check for breakout conditions
            breakout = patterns.get("breakout", {})
            if not breakout.get("breakout"):
                return None
            
            direction = breakout.get("direction")
            strength = breakout.get("strength", 0)
            volume_confirmation = breakout.get("volume_confirmation", False)
            
            # Require strong breakout with volume confirmation
            if strength < 0.03 or not volume_confirmation:  # Minimum 3% breakout
                return None
            
            # Check momentum indicators
            rsi = indicators.get("rsi", 50)
            macd_histogram = indicators.get("macd", {}).get("histogram", 0)
            
            # Volume surge requirement
            volume_ratio = volume / avg_volume if avg_volume > 0 else 1
            if volume_ratio < 1.5:  # Require 50% volume increase
                return None
            
            # Calculate signal strength
            signal_strength = min(1.0, (strength * 10 + volume_ratio * 0.2 + abs(macd_histogram) * 100) / 3)
            confidence = min(0.9, signal_strength * 0.8 + 0.1)
            
            if direction == "upward":
                # Call option strategy
                target_price = current_price * (1 + strength * 2.5)
                stop_loss = current_price * 0.97
                expected_return = 0.08  # Target 8% return
                
                return StrategySignal(
                    strategy_name="Momentum Breakout Call",
                    strategy_type=StrategyType.BREAKOUT,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    position_size=min(0.03, confidence * 0.04),
                    expected_return=expected_return,
                    max_risk=0.03,
                    time_horizon=72,  # 3 days
                    reasoning=f"Strong upward breakout ({strength:.1%}) with {volume_ratio:.1f}x volume surge",
                    technical_factors={
                        "breakout_strength": strength,
                        "volume_ratio": volume_ratio,
                        "rsi": rsi,
                        "macd_histogram": macd_histogram
                    },
                    options_factors={
                        "option_type": "call",
                        "strike_selection": "ATM",
                        "expiration": "weekly"
                    },
                    risk_factors={
                        "max_loss": 0.03,
                        "reward_risk_ratio": expected_return / 0.03,
                        "breakout_failure_risk": 0.25
                    }
                )
            
            elif direction == "downward":
                # Put option strategy
                target_price = current_price * (1 - strength * 2.5)
                stop_loss = current_price * 1.03
                expected_return = 0.08
                
                return StrategySignal(
                    strategy_name="Momentum Breakout Put",
                    strategy_type=StrategyType.BREAKOUT,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss=stop_loss,
                    position_size=min(0.03, confidence * 0.04),
                    expected_return=expected_return,
                    max_risk=0.03,
                    time_horizon=72,
                    reasoning=f"Strong downward breakout ({strength:.1%}) with {volume_ratio:.1f}x volume surge",
                    technical_factors={
                        "breakout_strength": strength,
                        "volume_ratio": volume_ratio,
                        "rsi": rsi,
                        "macd_histogram": macd_histogram
                    },
                    options_factors={
                        "option_type": "put",
                        "strike_selection": "ATM",
                        "expiration": "weekly"
                    },
                    risk_factors={
                        "max_loss": 0.03,
                        "reward_risk_ratio": expected_return / 0.03,
                        "breakout_failure_risk": 0.25
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error in momentum breakout strategy: {e}")
            return None
    
    def _volatility_squeeze_strategy(self, symbol: str, market_data: Dict[str, Any],
                                   analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Volatility squeeze strategy for explosive moves"""
        try:
            current_price = market_data.get("current_price", 0)
            indicators = analytics_data.get("indicators", {})
            
            # Get Bollinger Bands and ATR
            bollinger = indicators.get("bollinger_bands", {})
            atr = indicators.get("atr", 0)
            
            if not bollinger or not atr:
                return None
            
            upper_band = bollinger.get("upper", 0)
            lower_band = bollinger.get("lower", 0)
            middle_band = bollinger.get("middle", 0)
            
            # Calculate band width (volatility measure)
            if middle_band > 0:
                band_width = (upper_band - lower_band) / middle_band
            else:
                return None
            
            # Look for volatility squeeze (narrow bands)
            if band_width > 0.04:  # Bands too wide
                return None
            
            # Check for low volatility period
            if atr / current_price > 0.02:  # ATR too high
                return None
            
            # Get volume data
            volume = market_data.get("volume", 0)
            avg_volume = market_data.get("avg_volume", volume)
            volume_ratio = volume / avg_volume if avg_volume > 0 else 1
            
            # Look for increasing volume (potential breakout)
            if volume_ratio < 1.2:
                return None
            
            # Calculate signal strength based on squeeze tightness
            squeeze_strength = 1 - (band_width / 0.04)  # Tighter squeeze = higher strength
            signal_strength = min(1.0, squeeze_strength * volume_ratio * 0.5)
            confidence = min(0.85, signal_strength * 0.7 + 0.15)
            
            # Straddle strategy for volatility expansion
            expected_return = 0.12  # Higher return expectation for vol plays
            
            return StrategySignal(
                strategy_name="Volatility Squeeze Straddle",
                strategy_type=StrategyType.VOLATILITY,
                signal_strength=signal_strength,
                confidence=confidence,
                entry_price=current_price,
                target_price=current_price,  # Neutral target
                stop_loss=current_price,     # Neutral stop
                position_size=min(0.025, confidence * 0.03),
                expected_return=expected_return,
                max_risk=0.04,
                time_horizon=120,  # 5 days for vol expansion
                reasoning=f"Volatility squeeze detected (band width: {band_width:.3f}) with volume increase",
                technical_factors={
                    "band_width": band_width,
                    "atr_ratio": atr / current_price,
                    "volume_ratio": volume_ratio,
                    "squeeze_strength": squeeze_strength
                },
                options_factors={
                    "option_type": "straddle",
                    "strike_selection": "ATM",
                    "expiration": "2-3 weeks"
                },
                risk_factors={
                    "max_loss": 0.04,
                    "reward_risk_ratio": expected_return / 0.04,
                    "time_decay_risk": 0.3,
                    "volatility_risk": 0.2
                }
            )
            
        except Exception as e:
            logger.error(f"Error in volatility squeeze strategy: {e}")
            return None
    
    def _gamma_scalping_strategy(self, symbol: str, market_data: Dict[str, Any],
                               analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Gamma scalping strategy for high-frequency profits"""
        try:
            current_price = market_data.get("current_price", 0)
            
            # Get options Greeks
            greeks = options_data.get("greeks", {})
            gamma = greeks.get("gamma", 0)
            delta = greeks.get("delta", 0)
            theta = greeks.get("theta", 0)
            
            if not all([gamma, delta, theta]):
                return None
            
            # Look for high gamma opportunities
            if gamma < 0.05:  # Minimum gamma threshold
                return None
            
            # Check for favorable theta/gamma ratio
            theta_gamma_ratio = abs(theta) / gamma if gamma > 0 else float('inf')
            if theta_gamma_ratio > 2.0:  # Theta decay too high relative to gamma
                return None
            
            # Get volatility data
            indicators = analytics_data.get("indicators", {})
            atr = indicators.get("atr", 0)
            
            # Calculate expected scalping profit
            daily_range = atr
            scalping_opportunities = daily_range / (current_price * 0.005)  # Number of 0.5% moves
            
            if scalping_opportunities < 3:  # Need at least 3 scalping opportunities
                return None
            
            signal_strength = min(1.0, gamma * 10 + scalping_opportunities * 0.1)
            confidence = min(0.8, signal_strength * 0.6 + 0.2)
            
            expected_return = 0.06  # Conservative scalping return
            
            return StrategySignal(
                strategy_name="Gamma Scalping",
                strategy_type=StrategyType.GAMMA_SCALPING,
                signal_strength=signal_strength,
                confidence=confidence,
                entry_price=current_price,
                target_price=current_price,  # Neutral - profit from scalping
                stop_loss=current_price,     # Neutral - manage with delta hedging
                position_size=min(0.02, confidence * 0.025),
                expected_return=expected_return,
                max_risk=0.02,
                time_horizon=24,  # 1 day scalping
                reasoning=f"High gamma ({gamma:.3f}) with {scalping_opportunities:.1f} scalping opportunities",
                technical_factors={
                    "gamma": gamma,
                    "delta": delta,
                    "theta": theta,
                    "theta_gamma_ratio": theta_gamma_ratio,
                    "daily_range": daily_range,
                    "scalping_opportunities": scalping_opportunities
                },
                options_factors={
                    "option_type": "long_straddle",
                    "strike_selection": "ATM",
                    "expiration": "weekly",
                    "hedge_frequency": "every_0.5%_move"
                },
                risk_factors={
                    "max_loss": 0.02,
                    "reward_risk_ratio": expected_return / 0.02,
                    "execution_risk": 0.15,
                    "slippage_risk": 0.1
                }
            )
            
        except Exception as e:
            logger.error(f"Error in gamma scalping strategy: {e}")
            return None
    
    def _delta_neutral_straddle_strategy(self, symbol: str, market_data: Dict[str, Any],
                                       analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Delta neutral straddle for volatility plays"""
        try:
            current_price = market_data.get("current_price", 0)
            
            # Get implied volatility data
            iv_data = options_data.get("implied_volatility", {})
            current_iv = iv_data.get("current", 0)
            historical_iv = iv_data.get("historical_avg", current_iv)
            iv_percentile = iv_data.get("percentile", 50)
            
            if not current_iv or not historical_iv:
                return None
            
            # Look for low IV relative to historical
            iv_ratio = current_iv / historical_iv
            if iv_ratio > 0.8 or iv_percentile > 30:  # IV not low enough
                return None
            
            # Check for upcoming catalysts
            earnings_days = market_data.get("days_to_earnings", 999)
            has_catalyst = earnings_days <= 14  # Within 2 weeks of earnings
            
            if not has_catalyst:
                return None
            
            # Calculate expected volatility expansion
            vol_expansion_potential = (historical_iv - current_iv) / current_iv
            
            if vol_expansion_potential < 0.2:  # Need at least 20% vol expansion potential
                return None
            
            signal_strength = min(1.0, vol_expansion_potential * 2 + (50 - iv_percentile) / 50)
            confidence = min(0.85, signal_strength * 0.7 + 0.15)
            
            expected_return = 0.15  # Higher return for catalyst plays
            
            return StrategySignal(
                strategy_name="Delta Neutral Straddle",
                strategy_type=StrategyType.DELTA_NEUTRAL,
                signal_strength=signal_strength,
                confidence=confidence,
                entry_price=current_price,
                target_price=current_price,  # Neutral
                stop_loss=current_price,     # Neutral
                position_size=min(0.03, confidence * 0.035),
                expected_return=expected_return,
                max_risk=0.05,
                time_horizon=earnings_days * 24,  # Until earnings
                reasoning=f"Low IV ({iv_percentile}th percentile) before earnings in {earnings_days} days",
                technical_factors={
                    "current_iv": current_iv,
                    "historical_iv": historical_iv,
                    "iv_ratio": iv_ratio,
                    "iv_percentile": iv_percentile,
                    "vol_expansion_potential": vol_expansion_potential
                },
                options_factors={
                    "option_type": "long_straddle",
                    "strike_selection": "ATM",
                    "expiration": "post_earnings",
                    "delta_hedge": True
                },
                risk_factors={
                    "max_loss": 0.05,
                    "reward_risk_ratio": expected_return / 0.05,
                    "time_decay_risk": 0.4,
                    "volatility_risk": 0.3,
                    "earnings_risk": 0.2
                }
            )
            
        except Exception as e:
            logger.error(f"Error in delta neutral straddle strategy: {e}")
            return None
    
    def _iron_condor_range_strategy(self, symbol: str, market_data: Dict[str, Any],
                                  analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Iron condor strategy for range-bound markets"""
        try:
            current_price = market_data.get("current_price", 0)
            indicators = analytics_data.get("indicators", {})
            patterns = analytics_data.get("patterns", {})
            
            # Check for range-bound conditions
            support_resistance = patterns.get("support_resistance", {})
            support_level = support_resistance.get("support", 0)
            resistance_level = support_resistance.get("resistance", 0)
            
            if not support_level or not resistance_level:
                return None
            
            # Calculate range characteristics
            range_width = (resistance_level - support_level) / current_price
            price_position = (current_price - support_level) / (resistance_level - support_level)
            
            # Look for established range (minimum 3% width)
            if range_width < 0.03:
                return None
            
            # Price should be in middle of range
            if price_position < 0.3 or price_position > 0.7:
                return None
            
            # Check for low volatility
            atr = indicators.get("atr", 0)
            atr_ratio = atr / current_price
            
            if atr_ratio > 0.02:  # Volatility too high for range strategy
                return None
            
            # Get RSI for additional confirmation
            rsi = indicators.get("rsi", 50)
            if rsi < 40 or rsi > 60:  # RSI should be neutral
                return None
            
            signal_strength = min(1.0, range_width * 10 + (1 - abs(price_position - 0.5) * 2))
            confidence = min(0.8, signal_strength * 0.6 + 0.2)
            
            expected_return = 0.08  # Conservative range strategy
            
            return StrategySignal(
                strategy_name="Iron Condor Range",
                strategy_type=StrategyType.MEAN_REVERSION,
                signal_strength=signal_strength,
                confidence=confidence,
                entry_price=current_price,
                target_price=current_price,  # Neutral - profit from range
                stop_loss=current_price,     # Neutral - manage with range breaks
                position_size=min(0.02, confidence * 0.025),
                expected_return=expected_return,
                max_risk=0.03,
                time_horizon=168,  # 1 week
                reasoning=f"Range-bound market ({range_width:.1%} range) with price in middle",
                technical_factors={
                    "support_level": support_level,
                    "resistance_level": resistance_level,
                    "range_width": range_width,
                    "price_position": price_position,
                    "atr_ratio": atr_ratio,
                    "rsi": rsi
                },
                options_factors={
                    "option_type": "iron_condor",
                    "strike_selection": "OTM",
                    "expiration": "monthly",
                    "profit_target": "50%_max_profit"
                },
                risk_factors={
                    "max_loss": 0.03,
                    "reward_risk_ratio": expected_return / 0.03,
                    "range_break_risk": 0.25,
                    "time_decay_benefit": 0.3
                }
            )
            
        except Exception as e:
            logger.error(f"Error in iron condor range strategy: {e}")
            return None
    
    def _butterfly_pinning_strategy(self, symbol: str, market_data: Dict[str, Any],
                                  analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Butterfly strategy for pin risk scenarios"""
        try:
            current_price = market_data.get("current_price", 0)
            
            # Get options data
            options_chain = options_data.get("options_chain", {})
            if not options_chain:
                return None
            
            # Look for high open interest at specific strikes
            max_oi_strike = 0
            max_oi = 0
            
            for strike, data in options_chain.items():
                total_oi = data.get("call_oi", 0) + data.get("put_oi", 0)
                if total_oi > max_oi:
                    max_oi = total_oi
                    max_oi_strike = float(strike)
            
            if max_oi < 1000:  # Minimum OI threshold
                return None
            
            # Check if current price is near max OI strike
            distance_to_strike = abs(current_price - max_oi_strike) / current_price
            
            if distance_to_strike > 0.02:  # More than 2% away
                return None
            
            # Check time to expiration
            expiration_days = market_data.get("days_to_expiration", 0)
            if expiration_days > 7 or expiration_days < 1:  # 1-7 days optimal
                return None
            
            # Calculate pin probability
            pin_probability = max_oi / (max_oi + 5000)  # Normalize OI
            pin_probability *= (1 - distance_to_strike * 50)  # Distance factor
            pin_probability *= (8 - expiration_days) / 7  # Time factor
            
            signal_strength = min(1.0, pin_probability * 2)
            confidence = min(0.75, signal_strength * 0.6 + 0.15)
            
            expected_return = 0.10  # Good return for pin plays
            
            return StrategySignal(
                strategy_name="Butterfly Pin",
                strategy_type=StrategyType.ARBITRAGE,
                signal_strength=signal_strength,
                confidence=confidence,
                entry_price=current_price,
                target_price=max_oi_strike,
                stop_loss=current_price,
                position_size=min(0.025, confidence * 0.03),
                expected_return=expected_return,
                max_risk=0.03,
                time_horizon=expiration_days * 24,
                reasoning=f"High OI ({max_oi:,}) at ${max_oi_strike} with {expiration_days} days to expiry",
                technical_factors={
                    "max_oi_strike": max_oi_strike,
                    "max_oi": max_oi,
                    "distance_to_strike": distance_to_strike,
                    "expiration_days": expiration_days,
                    "pin_probability": pin_probability
                },
                options_factors={
                    "option_type": "butterfly",
                    "strike_selection": "max_oi_center",
                    "expiration": "weekly",
                    "wing_width": "2-3%"
                },
                risk_factors={
                    "max_loss": 0.03,
                    "reward_risk_ratio": expected_return / 0.03,
                    "pin_failure_risk": 1 - pin_probability,
                    "time_decay_risk": 0.2
                }
            )
            
        except Exception as e:
            logger.error(f"Error in butterfly pinning strategy: {e}")
            return None
    
    def _earnings_volatility_strategy(self, symbol: str, market_data: Dict[str, Any],
                                    analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Earnings volatility strategy"""
        try:
            current_price = market_data.get("current_price", 0)
            earnings_days = market_data.get("days_to_earnings", 999)
            
            if earnings_days > 10 or earnings_days < 1:  # 1-10 days before earnings
                return None
            
            # Get implied volatility data
            iv_data = options_data.get("implied_volatility", {})
            current_iv = iv_data.get("current", 0)
            earnings_iv = iv_data.get("earnings_avg", current_iv)
            
            if not current_iv or not earnings_iv:
                return None
            
            # Calculate expected move
            expected_move = current_price * current_iv * math.sqrt(1/365)  # Daily move
            
            # Get historical earnings moves
            historical_moves = market_data.get("historical_earnings_moves", [])
            if len(historical_moves) >= 4:
                avg_historical_move = np.mean(historical_moves)
                historical_volatility = np.std(historical_moves)
            else:
                avg_historical_move = expected_move
                historical_volatility = expected_move * 0.5
            
            # Compare implied vs historical
            iv_vs_historical = expected_move / avg_historical_move if avg_historical_move > 0 else 1
            
            # Strategy selection based on IV vs historical
            if iv_vs_historical < 0.8:  # IV underpricing the move
                strategy_type = "long_straddle"
                expected_return = 0.18
                reasoning = f"IV underpricing earnings move (implied: {expected_move/current_price:.1%}, historical: {avg_historical_move/current_price:.1%})"
            elif iv_vs_historical > 1.3:  # IV overpricing the move
                strategy_type = "short_straddle"
                expected_return = 0.12
                reasoning = f"IV overpricing earnings move (implied: {expected_move/current_price:.1%}, historical: {avg_historical_move/current_price:.1%})"
            else:
                return None  # Fair pricing
            
            signal_strength = min(1.0, abs(iv_vs_historical - 1) * 2)
            confidence = min(0.8, signal_strength * 0.6 + 0.2)
            
            return StrategySignal(
                strategy_name=f"Earnings {strategy_type.replace('_', ' ').title()}",
                strategy_type=StrategyType.VOLATILITY,
                signal_strength=signal_strength,
                confidence=confidence,
                entry_price=current_price,
                target_price=current_price,  # Neutral
                stop_loss=current_price,     # Neutral
                position_size=min(0.04, confidence * 0.05),
                expected_return=expected_return,
                max_risk=0.06,
                time_horizon=earnings_days * 24,
                reasoning=reasoning,
                technical_factors={
                    "earnings_days": earnings_days,
                    "current_iv": current_iv,
                    "expected_move": expected_move,
                    "avg_historical_move": avg_historical_move,
                    "iv_vs_historical": iv_vs_historical
                },
                options_factors={
                    "option_type": strategy_type,
                    "strike_selection": "ATM",
                    "expiration": "post_earnings",
                    "exit_strategy": "before_earnings" if strategy_type == "long_straddle" else "after_earnings"
                },
                risk_factors={
                    "max_loss": 0.06,
                    "reward_risk_ratio": expected_return / 0.06,
                    "earnings_surprise_risk": 0.4,
                    "volatility_crush_risk": 0.3 if strategy_type == "long_straddle" else 0.1
                }
            )
            
        except Exception as e:
            logger.error(f"Error in earnings volatility strategy: {e}")
            return None
    
    def _gap_fill_reversal_strategy(self, symbol: str, market_data: Dict[str, Any],
                                  analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Gap fill reversal strategy"""
        try:
            current_price = market_data.get("current_price", 0)
            previous_close = market_data.get("previous_close", current_price)
            
            # Calculate gap
            gap_size = (current_price - previous_close) / previous_close
            
            if abs(gap_size) < 0.02:  # Minimum 2% gap
                return None
            
            # Get volume data
            volume = market_data.get("volume", 0)
            avg_volume = market_data.get("avg_volume", volume)
            volume_ratio = volume / avg_volume if avg_volume > 0 else 1
            
            # Check for gap characteristics
            gap_direction = "up" if gap_size > 0 else "down"
            
            # Look for exhaustion signs
            indicators = analytics_data.get("indicators", {})
            rsi = indicators.get("rsi", 50)
            
            # Gap up exhaustion
            if gap_direction == "up" and rsi > 75 and volume_ratio > 2:
                signal_strength = min(1.0, abs(gap_size) * 10 + (rsi - 75) / 25)
                confidence = min(0.8, signal_strength * 0.7 + 0.1)
                
                target_price = previous_close + (current_price - previous_close) * 0.3  # 70% gap fill
                expected_return = 0.07
                
                return StrategySignal(
                    strategy_name="Gap Fill Reversal Put",
                    strategy_type=StrategyType.MEAN_REVERSION,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss=current_price * 1.02,
                    position_size=min(0.025, confidence * 0.03),
                    expected_return=expected_return,
                    max_risk=0.02,
                    time_horizon=48,  # 2 days
                    reasoning=f"Gap up exhaustion ({gap_size:.1%} gap) with RSI {rsi:.0f}",
                    technical_factors={
                        "gap_size": gap_size,
                        "volume_ratio": volume_ratio,
                        "rsi": rsi,
                        "previous_close": previous_close
                    },
                    options_factors={
                        "option_type": "put",
                        "strike_selection": "ATM",
                        "expiration": "weekly"
                    },
                    risk_factors={
                        "max_loss": 0.02,
                        "reward_risk_ratio": expected_return / 0.02,
                        "gap_continuation_risk": 0.3
                    }
                )
            
            # Gap down exhaustion
            elif gap_direction == "down" and rsi < 25 and volume_ratio > 2:
                signal_strength = min(1.0, abs(gap_size) * 10 + (25 - rsi) / 25)
                confidence = min(0.8, signal_strength * 0.7 + 0.1)
                
                target_price = previous_close + (current_price - previous_close) * 0.3  # 70% gap fill
                expected_return = 0.07
                
                return StrategySignal(
                    strategy_name="Gap Fill Reversal Call",
                    strategy_type=StrategyType.MEAN_REVERSION,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss=current_price * 0.98,
                    position_size=min(0.025, confidence * 0.03),
                    expected_return=expected_return,
                    max_risk=0.02,
                    time_horizon=48,
                    reasoning=f"Gap down exhaustion ({gap_size:.1%} gap) with RSI {rsi:.0f}",
                    technical_factors={
                        "gap_size": gap_size,
                        "volume_ratio": volume_ratio,
                        "rsi": rsi,
                        "previous_close": previous_close
                    },
                    options_factors={
                        "option_type": "call",
                        "strike_selection": "ATM",
                        "expiration": "weekly"
                    },
                    risk_factors={
                        "max_loss": 0.02,
                        "reward_risk_ratio": expected_return / 0.02,
                        "gap_continuation_risk": 0.3
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error in gap fill reversal strategy: {e}")
            return None
    
    def _support_resistance_bounce_strategy(self, symbol: str, market_data: Dict[str, Any],
                                          analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """Support/resistance bounce strategy"""
        try:
            current_price = market_data.get("current_price", 0)
            patterns = analytics_data.get("patterns", {})
            
            support_resistance = patterns.get("support_resistance", {})
            support_level = support_resistance.get("support", 0)
            resistance_level = support_resistance.get("resistance", 0)
            support_strength = support_resistance.get("support_strength", 0)
            resistance_strength = support_resistance.get("resistance_strength", 0)
            
            if not support_level or not resistance_level:
                return None
            
            # Check distance to support/resistance
            distance_to_support = (current_price - support_level) / current_price
            distance_to_resistance = (resistance_level - current_price) / current_price
            
            # Look for bounce opportunities
            if distance_to_support <= 0.01 and support_strength >= 3:  # Within 1% of strong support
                signal_strength = min(1.0, support_strength / 5 + (0.01 - distance_to_support) * 100)
                confidence = min(0.8, signal_strength * 0.7 + 0.1)
                
                target_price = support_level + (resistance_level - support_level) * 0.6  # 60% of range
                expected_return = 0.06
                
                return StrategySignal(
                    strategy_name="Support Bounce Call",
                    strategy_type=StrategyType.MEAN_REVERSION,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss=support_level * 0.99,
                    position_size=min(0.02, confidence * 0.025),
                    expected_return=expected_return,
                    max_risk=0.02,
                    time_horizon=72,  # 3 days
                    reasoning=f"Strong support bounce at ${support_level:.2f} (strength: {support_strength})",
                    technical_factors={
                        "support_level": support_level,
                        "support_strength": support_strength,
                        "distance_to_support": distance_to_support,
                        "resistance_level": resistance_level
                    },
                    options_factors={
                        "option_type": "call",
                        "strike_selection": "ATM",
                        "expiration": "weekly"
                    },
                    risk_factors={
                        "max_loss": 0.02,
                        "reward_risk_ratio": expected_return / 0.02,
                        "support_break_risk": 0.2
                    }
                )
            
            elif distance_to_resistance <= 0.01 and resistance_strength >= 3:  # Within 1% of strong resistance
                signal_strength = min(1.0, resistance_strength / 5 + (0.01 - distance_to_resistance) * 100)
                confidence = min(0.8, signal_strength * 0.7 + 0.1)
                
                target_price = resistance_level - (resistance_level - support_level) * 0.6  # 60% of range
                expected_return = 0.06
                
                return StrategySignal(
                    strategy_name="Resistance Bounce Put",
                    strategy_type=StrategyType.MEAN_REVERSION,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss=resistance_level * 1.01,
                    position_size=min(0.02, confidence * 0.025),
                    expected_return=expected_return,
                    max_risk=0.02,
                    time_horizon=72,
                    reasoning=f"Strong resistance bounce at ${resistance_level:.2f} (strength: {resistance_strength})",
                    technical_factors={
                        "resistance_level": resistance_level,
                        "resistance_strength": resistance_strength,
                        "distance_to_resistance": distance_to_resistance,
                        "support_level": support_level
                    },
                    options_factors={
                        "option_type": "put",
                        "strike_selection": "ATM",
                        "expiration": "weekly"
                    },
                    risk_factors={
                        "max_loss": 0.02,
                        "reward_risk_ratio": expected_return / 0.02,
                        "resistance_break_risk": 0.2
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error in support/resistance bounce strategy: {e}")
            return None
    
    def _vix_divergence_strategy(self, symbol: str, market_data: Dict[str, Any],
                               analytics_data: Dict[str, Any], options_data: Dict[str, Any]) -> Optional[StrategySignal]:
        """VIX divergence strategy for market timing"""
        try:
            # Only apply to SPY and QQQ
            if symbol not in ["SPY", "QQQ"]:
                return None
            
            current_price = market_data.get("current_price", 0)
            
            # Get VIX data
            vix_data = market_data.get("vix_data", {})
            current_vix = vix_data.get("current", 0)
            vix_ma = vix_data.get("moving_average", current_vix)
            vix_percentile = vix_data.get("percentile", 50)
            
            if not current_vix or not vix_ma:
                return None
            
            # Get market trend
            indicators = analytics_data.get("indicators", {})
            sma_20 = indicators.get("sma_20", current_price)
            sma_50 = indicators.get("sma_50", current_price)
            
            # Calculate price trend
            price_trend = (current_price - sma_20) / sma_20
            longer_trend = (sma_20 - sma_50) / sma_50
            
            # Look for VIX divergences
            vix_deviation = (current_vix - vix_ma) / vix_ma
            
            # High VIX with market decline (potential reversal)
            if vix_percentile > 80 and price_trend < -0.02 and longer_trend > -0.01:
                signal_strength = min(1.0, (vix_percentile - 80) / 20 + abs(price_trend) * 10)
                confidence = min(0.75, signal_strength * 0.6 + 0.15)
                
                expected_return = 0.08
                
                return StrategySignal(
                    strategy_name="VIX Divergence Call",
                    strategy_type=StrategyType.MEAN_REVERSION,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=current_price * 1.04,
                    stop_loss=current_price * 0.98,
                    position_size=min(0.03, confidence * 0.035),
                    expected_return=expected_return,
                    max_risk=0.02,
                    time_horizon=120,  # 5 days
                    reasoning=f"High VIX ({vix_percentile}th percentile) with market oversold",
                    technical_factors={
                        "current_vix": current_vix,
                        "vix_percentile": vix_percentile,
                        "vix_deviation": vix_deviation,
                        "price_trend": price_trend,
                        "longer_trend": longer_trend
                    },
                    options_factors={
                        "option_type": "call",
                        "strike_selection": "ATM",
                        "expiration": "2_weeks"
                    },
                    risk_factors={
                        "max_loss": 0.02,
                        "reward_risk_ratio": expected_return / 0.02,
                        "market_continuation_risk": 0.3
                    }
                )
            
            # Low VIX with market rally (potential reversal)
            elif vix_percentile < 20 and price_trend > 0.02 and longer_trend < 0.01:
                signal_strength = min(1.0, (20 - vix_percentile) / 20 + price_trend * 10)
                confidence = min(0.75, signal_strength * 0.6 + 0.15)
                
                expected_return = 0.08
                
                return StrategySignal(
                    strategy_name="VIX Divergence Put",
                    strategy_type=StrategyType.MEAN_REVERSION,
                    signal_strength=signal_strength,
                    confidence=confidence,
                    entry_price=current_price,
                    target_price=current_price * 0.96,
                    stop_loss=current_price * 1.02,
                    position_size=min(0.03, confidence * 0.035),
                    expected_return=expected_return,
                    max_risk=0.02,
                    time_horizon=120,
                    reasoning=f"Low VIX ({vix_percentile}th percentile) with market overbought",
                    technical_factors={
                        "current_vix": current_vix,
                        "vix_percentile": vix_percentile,
                        "vix_deviation": vix_deviation,
                        "price_trend": price_trend,
                        "longer_trend": longer_trend
                    },
                    options_factors={
                        "option_type": "put",
                        "strike_selection": "ATM",
                        "expiration": "2_weeks"
                    },
                    risk_factors={
                        "max_loss": 0.02,
                        "reward_risk_ratio": expected_return / 0.02,
                        "market_continuation_risk": 0.3
                    }
                )
            
            return None
            
        except Exception as e:
            logger.error(f"Error in VIX divergence strategy: {e}")
            return None
    
    def _validate_strategy_signal(self, signal: StrategySignal) -> bool:
        """Validate strategy signal meets quality criteria"""
        try:
            # Check minimum confidence
            if signal.confidence < 0.6:
                return False
            
            # Check risk/reward ratio
            if signal.max_risk > 0 and signal.expected_return / signal.max_risk < 2.0:
                return False
            
            # Check position size
            if signal.position_size > 0.05:  # Maximum 5%
                return False
            
            # Check time horizon
            if signal.time_horizon < 1 or signal.time_horizon > 720:  # 1 hour to 30 days
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Error validating strategy signal: {e}")
            return False
    
    def get_strategy_performance(self) -> Dict[str, Any]:
        """Get performance metrics for all strategies"""
        return self.strategy_performance.copy()
    
    def update_strategy_performance(self, strategy_name: str, performance_data: Dict[str, Any]):
        """Update strategy performance metrics"""
        if strategy_name not in self.strategy_performance:
            self.strategy_performance[strategy_name] = {
                "total_signals": 0,
                "winning_signals": 0,
                "total_return": 0.0,
                "average_return": 0.0,
                "win_rate": 0.0,
                "sharpe_ratio": 0.0,
                "max_drawdown": 0.0
            }
        
        perf = self.strategy_performance[strategy_name]
        perf["total_signals"] += 1
        
        if performance_data.get("return", 0) > 0:
            perf["winning_signals"] += 1
        
        perf["total_return"] += performance_data.get("return", 0)
        perf["average_return"] = perf["total_return"] / perf["total_signals"]
        perf["win_rate"] = perf["winning_signals"] / perf["total_signals"]
        
        # Update strategy weights based on performance
        self._update_strategy_weights()
    
    def _update_strategy_weights(self):
        """Update strategy weights based on performance"""
        total_performance = 0
        strategy_scores = {}
        
        for strategy_name, perf in self.strategy_performance.items():
            if perf["total_signals"] >= 10:  # Minimum signals for weight adjustment
                score = perf["win_rate"] * perf["average_return"] * (1 - perf["max_drawdown"])
                strategy_scores[strategy_name] = max(0.01, score)  # Minimum weight
                total_performance += strategy_scores[strategy_name]
        
        if total_performance > 0:
            for strategy_name, score in strategy_scores.items():
                self.strategy_weights[strategy_name] = score / total_performance

# Factory function
def create_strategy_engine() -> OptionsStrategyEngine:
    """Create options strategy engine"""
    return OptionsStrategyEngine()

if __name__ == "__main__":
    # Example usage
    engine = create_strategy_engine()
    
    # Mock data for testing
    market_data = {
        "current_price": 150.0,
        "volume": 1000000,
        "avg_volume": 800000,
        "previous_close": 148.0,
        "days_to_earnings": 5
    }
    
    analytics_data = {
        "indicators": {
            "rsi": 75,
            "atr": 3.0,
            "bollinger_bands": {
                "upper": 155,
                "lower": 145,
                "middle": 150
            },
            "macd": {
                "macd": 0.5,
                "signal": 0.3,
                "histogram": 0.2
            }
        },
        "patterns": {
            "breakout": {
                "breakout": True,
                "direction": "upward",
                "strength": 0.04,
                "volume_confirmation": True
            }
        }
    }
    
    options_data = {
        "greeks": {
            "gamma": 0.08,
            "delta": 0.6,
            "theta": -0.05
        },
        "implied_volatility": {
            "current": 0.25,
            "historical_avg": 0.30,
            "percentile": 20
        }
    }
    
    signals = engine.analyze_opportunities("AAPL", market_data, analytics_data, options_data)
    
    print(f"Generated {len(signals)} strategy signals:")
    for signal in signals:
        print(f"- {signal.strategy_name}: {signal.confidence:.2f} confidence, {signal.expected_return:.1%} expected return")

